#!/bin/bash

# HTTPVerb - HTTP Method Enumeration Tool
# Tests all HTTP methods/verbs against single or multiple domains
# Version: 1.0

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# HTTP Methods to test
METHODS=("GET" "POST" "PUT" "DELETE" "PATCH" "HEAD" "OPTIONS" "TRACE" "CONNECT")

# Output file
OUTPUT_FILE="http_methods_test_$(date +%Y%m%d_%H%M%S).txt"
CSV_FILE="http_methods_test_$(date +%Y%m%d_%H%M%S).csv"

print_banner() {
    echo -e "${PURPLE}"
    echo "═══════════════════════════════════════════════════"
    echo "          HTTPVerb - Method Enumeration Tool"
    echo "                    Version 1.0"
    echo "═══════════════════════════════════════════════════"
    echo -e "${NC}"
}

print_usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -d <domain>       Test single domain (e.g., example.com)"
    echo "  -f <file>         Test domains from file (one per line)"
    echo "  -l <list>         Test comma-separated list of domains"
    echo "  -o <file>         Output file (default: http_methods_test_TIMESTAMP.txt)"
    echo "  -c                Export results to CSV"
    echo "  -v                Verbose mode (show full responses)"
    echo "  -t <timeout>      Request timeout in seconds (default: 10)"
    echo "  -h                Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 -d example.com"
    echo "  $0 -f domains.txt -c"
    echo "  $0 -l \"api.example.com,www.example.com\""
    echo "  $0 -d example.com -v -t 5"
}

normalize_url() {
    local url="$1"
    # Add https:// if no protocol specified
    if [[ ! "$url" =~ ^https?:// ]]; then
        url="https://$url"
    fi
    echo "$url"
}

test_method() {
    local url="$1"
    local method="$2"
    local timeout="$3"
    local verbose="$4"
    
    # Perform the request
    local response=$(curl -s -o /dev/null -w "%{http_code}|%{time_total}|%{size_download}" \
        -X "$method" \
        --max-time "$timeout" \
        -H "User-Agent: HTTP-Method-Tester/1.0" \
        "$url" 2>&1)
    
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        IFS='|' read -r status_code time_total size <<< "$response"
        
        # Determine if method is allowed based on status code
        local allowed="Unknown"
        local color=$YELLOW
        
        if [ "$status_code" -ge 200 ] && [ "$status_code" -lt 300 ]; then
            allowed="Allowed"
            color=$GREEN
        elif [ "$status_code" -eq 405 ]; then
            allowed="Not Allowed"
            color=$RED
        elif [ "$status_code" -eq 401 ] || [ "$status_code" -eq 403 ]; then
            allowed="Requires Auth"
            color=$YELLOW
        elif [ "$status_code" -ge 400 ]; then
            allowed="Client Error"
            color=$RED
        elif [ "$status_code" -ge 500 ]; then
            allowed="Server Error"
            color=$RED
        fi
        
        echo -e "  ${color}[${method}]${NC} Status: $status_code | $allowed | Time: ${time_total}s"
        
        if [ "$verbose" = true ]; then
            echo "    Size: ${size} bytes"
        fi
        
        # Return for CSV export
        echo "$url,$method,$status_code,$allowed,$time_total" >> "$CSV_FILE.tmp"
    else
        echo -e "  ${RED}[${method}]${NC} Error: Connection failed (timeout or unreachable)"
        echo "$url,$method,ERROR,Connection Failed,0" >> "$CSV_FILE.tmp"
    fi
}

test_domain() {
    local domain="$1"
    local timeout="$2"
    local verbose="$3"
    
    local url=$(normalize_url "$domain")
    
    echo -e "\n${CYAN}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║${NC} Testing: ${BLUE}$url${NC}"
    echo -e "${CYAN}╚════════════════════════════════════════════════════════════╝${NC}"
    
    # Write to output file
    echo "" >> "$OUTPUT_FILE"
    echo "Testing: $url" >> "$OUTPUT_FILE"
    echo "Timestamp: $(date)" >> "$OUTPUT_FILE"
    echo "----------------------------------------" >> "$OUTPUT_FILE"
    
    for method in "${METHODS[@]}"; do
        test_method "$url" "$method" "$timeout" "$verbose" | tee -a "$OUTPUT_FILE"
        sleep 0.5  # Small delay between requests
    done
}

# Main script
main() {
    local domain=""
    local file=""
    local list=""
    local export_csv=false
    local verbose=false
    local timeout=10
    
    # Parse arguments
    while getopts "d:f:l:o:cvt:h" opt; do
        case $opt in
            d) domain="$OPTARG" ;;
            f) file="$OPTARG" ;;
            l) list="$OPTARG" ;;
            o) OUTPUT_FILE="$OPTARG" ;;
            c) export_csv=true ;;
            v) verbose=true ;;
            t) timeout="$OPTARG" ;;
            h) print_usage; exit 0 ;;
            *) print_usage; exit 1 ;;
        esac
    done
    
    print_banner
    
    # Check if curl is installed
    if ! command -v curl &> /dev/null; then
        echo -e "${RED}Error: curl is not installed. Please install curl first.${NC}"
        exit 1
    fi
    
    # Initialize CSV if needed
    if [ "$export_csv" = true ]; then
        echo "URL,Method,Status Code,Result,Response Time" > "$CSV_FILE.tmp"
    fi
    
    # Test based on input type
    if [ -n "$domain" ]; then
        test_domain "$domain" "$timeout" "$verbose"
    elif [ -n "$file" ]; then
        if [ ! -f "$file" ]; then
            echo -e "${RED}Error: File '$file' not found${NC}"
            exit 1
        fi
        echo -e "${YELLOW}Testing domains from file: $file${NC}"
        while IFS= read -r line; do
            [ -z "$line" ] && continue
            [[ "$line" =~ ^#.* ]] && continue  # Skip comments
            test_domain "$line" "$timeout" "$verbose"
        done < "$file"
    elif [ -n "$list" ]; then
        IFS=',' read -ra DOMAINS <<< "$list"
        for d in "${DOMAINS[@]}"; do
            test_domain "$(echo $d | xargs)" "$timeout" "$verbose"
        done
    else
        echo -e "${RED}Error: No domain specified${NC}\n"
        print_usage
        exit 1
    fi
    
    # Finalize CSV
    if [ "$export_csv" = true ] && [ -f "$CSV_FILE.tmp" ]; then
        mv "$CSV_FILE.tmp" "$CSV_FILE"
        echo -e "\n${GREEN}✓ CSV exported to: $CSV_FILE${NC}"
    fi
    
    echo -e "\n${GREEN}✓ Results saved to: $OUTPUT_FILE${NC}"
    echo -e "${CYAN}════════════════════════════════════════════════════════════${NC}\n"
}

# Run main function
main "$@"
